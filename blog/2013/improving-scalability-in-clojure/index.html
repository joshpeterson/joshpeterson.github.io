<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Improving Scalability in Clojure | Josh Peterson </title> <meta name="author" content="Josh Peterson"> <meta name="description" content="Josh's personal website "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%91%8B&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://joshpeterson.github.io/blog/2013/improving-scalability-in-clojure/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Josh</span> Peterson </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/philosophy/">philosophy </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/repositories/">repositories</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/publications/">publications</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Improving Scalability in Clojure</h1> <p class="post-meta"> Created in May 11, 2013 </p> <p class="post-tags"> <a href="/blog/2013"> <i class="fa-solid fa-calendar fa-sm"></i> 2013 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In my <a href="/blog/2013/scalability-in-a-functional-language/">last post</a> I compared the scalability of a CPU-bound algorithm in both C++ and Clojure. Although the Clojure implementation had no real data sharing, it used significantly more memory than necessary, which lead to false sharing, and limited the scalability of the implementation. In this post, I’ll explain my attempts to improve the scalability of the Clojure implementation by limiting its memory usage.</p> <h2 id="tldr">TL;DR</h2> <p>I was unable to significantly lessen the memory usage of the Clojure implementation. By comparing the Clojure implementation on both the JVM and the CLR, it seems clear that less memory usage leads to fewer cache misses, and better scalability. Since this algorithm has no intrinsic data sharing, and can be implemented to scale effectively in an imperative language without too much difficulty.</p> <h2 id="stay-lazy">Stay Lazy</h2> <p>One of the most important tools provided by Clojure is the <a href="http://clojure.org/sequences" rel="external nofollow noopener" target="_blank">lazy sequence</a>. A sequence of all prime numbers, for example, doesn’t actually store all prime numbers. Instead, it provides each prime number as the client asks, computing the next prime only when necessary. Certain actions in Clojure can limit the ability of the language to be lazy, requiring it to iterate large sequences and store the results in memory.</p> <p>The partitioning function in my original implementation in Clojure suffered from this exact problem. The partitioning function is responsible for the separation of the input (large large sequence of consecutive integers, often millions of integers) into equally sized groups. Each thread will operate on one group. The original code for the partitioning function looks like this:</p> <figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">partition-nash-games</span><span class="w">
  </span><span class="p">[</span><span class="n">number-of-partitions</span><span class="w"> </span><span class="n">number-of-rows</span><span class="w">
   </span><span class="n">number-of-columns</span><span class="w"> </span><span class="n">games</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">number-of-games</span><span class="w">
         </span><span class="p">(</span><span class="nf">number-of-nash-games</span><span class="w"> </span><span class="n">number-of-rows</span><span class="w">
                               </span><span class="n">number-of-columns</span><span class="p">)</span><span class="w">
        </span><span class="n">partitions</span><span class="w"> </span><span class="p">(</span><span class="nf">partition-all</span><span class="w"> </span><span class="p">(</span><span class="nb">quot</span><span class="w"> </span><span class="n">number-of-games</span><span class="w">
                                        </span><span class="n">number-of-partitions</span><span class="p">)</span><span class="w">
                                  </span><span class="n">games</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">rem</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">games</span><span class="p">)</span><span class="w"> </span><span class="n">number-of-partitions</span><span class="p">))</span><span class="w">
      </span><span class="n">partitions</span><span class="w">
      </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">number-of-partitions</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">partitions</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">concat</span><span class="w"> </span><span class="p">(</span><span class="nf">take-last</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">partitions</span><span class="p">))))))</span></code></pre></figure> <p>Here is the section of this code which prevents Clojure’s normal laziness:</p> <figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">partition-all</span><span class="w"> </span><span class="p">(</span><span class="nb">quot</span><span class="w"> </span><span class="n">number-of-games</span><span class="w"> </span><span class="n">number-of-partitions</span><span class="p">)</span><span class="w">
               </span><span class="n">games</span><span class="p">)]</span></code></pre></figure> <p>Here <code>games</code> is a lazy sequence of all integers from 0 to the number of games. The <a href="http://clojuredocs.org/clojure_core/1.3.0/clojure.core/partition-all" rel="external nofollow noopener" target="_blank"><code>partition-all</code></a> function iterates all of the integers and creates subsequences of a given size. Instead of using the laziness of Clojure sequences to minimize the memory usage for these large sequences, this implementation requires all of the integers to be stored in memory.</p> <h2 id="thinking-functionally">Thinking Functionally</h2> <p>Unfortunately, I find myself continuing to think in imperative languages even when I’m writing code in functional languages. So I found it useful to express this code in an imperative language to help me determine how to improve it.</p> <blockquote> <p>Digression:</p> <p>In high school, I remember talking with an exchange student from Brazil one day. He was very happy, since he had dreamt in English for the first time the previous night. This was an indication that he was beginning to think in English, instead of translating from English to Portuguese in his mind. This allowed him to think faster.</p> <p>For the same reason, I often feel that I’m thinking to slowly while writing code in a functional language.</p> </blockquote> <p>If I express the code for the <code>partition-all</code> function in C++, it might look like this:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">partition</span><span class="o">-</span><span class="n">all</span><span class="p">(</span><span class="kt">int</span> <span class="n">partition_size</span><span class="p">,</span>
                                  <span class="kt">int</span> <span class="n">number_of_games</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">partitions</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">current_partition</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">entries_in_current_partition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_games</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entries_in_current_partition</span> <span class="o">&lt;</span> <span class="n">partition_size</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">current_partition</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="o">++</span><span class="n">entries_in_current_partition</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">partitions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current_partition</span><span class="p">);</span>
            <span class="n">current_partition</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="n">entries_in_current_partition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">partitions</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>When the code is expressed this way, I can clearly see that it will use a signifigant amount of memory, storing each of the consecutive integers. Instead, it should only store the start and end index of each partition. Here is a better implementation in C++:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">partition</span><span class="o">-</span><span class="n">all</span><span class="p">(</span><span class="kt">int</span> <span class="n">partition_size</span><span class="p">,</span>
                                     <span class="kt">int</span> <span class="n">number_of_games</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">partitions_indices</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">entries_in_current_partition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">current_start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">current_end_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_games</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entries_in_current_partition</span> <span class="o">&lt;</span> <span class="n">partition_size</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">current_end_index</span><span class="p">;</span>
            <span class="o">++</span><span class="n">entries_in_current_partition</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">partitions_indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
                    <span class="n">make_pair</span><span class="p">(</span><span class="n">current_start_index</span><span class="p">,</span>
                              <span class="n">current_end_index</span><span class="p">));</span>
            <span class="n">current_start_index</span> <span class="o">=</span> <span class="n">current_end_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="o">++</span><span class="n">current_end_index</span><span class="p">;</span>
            <span class="n">entries_in_current_partition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">partition_indices</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <p>The corresponding code in Clojure to return a sequence of only the start and end indices for each partition is this:</p> <figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="n">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">entries-per-partition</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
 </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">number-of-games</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">
                   </span><span class="n">entries-per-partition</span><span class="p">)</span><span class="w">
               </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">entries-per-partition</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="n">number-of-games</span><span class="p">)))</span></code></pre></figure> <p>I often find that I understand Clojure code when I think about it backwards, using the REPL to unroll the meaning of each statement. Let’s consider this code for a 2x2 game (16 possible games) with partitions of size 4.</p> <figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="n">nash-clojure.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span></code></pre></figure> <p>This part of the code builds a lazy sequence of the values to iterate. It corresponds to the for loop in the C++ implementation.</p> <figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="n">nash-clojure.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
                 </span><span class="n">=&gt;</span><span class="w">               </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">16</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span></code></pre></figure> <p>The next part of the code finds the starting index of each partition. Since we don’t use mutable state in Clojure, we cannot walk the end index of each partition as we do in C++. Instead, we do the reverse (in some sense), and pick off the start index of each partition from the sequence of all indices.</p> <figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="n">nash-clojure.core=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="n">%</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
                 </span><span class="n">=&gt;</span><span class="w">      </span><span class="o">'</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">12</span><span class="p">))</span><span class="w">
</span><span class="p">([</span><span class="mi">0</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="w"> </span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="mi">15</span><span class="p">])</span></code></pre></figure> <p>Finally, the code <a href="http://clojuredocs.org/clojure_core/clojure.core/conj" rel="external nofollow noopener" target="_blank">conjoins</a> each start index with the corresponding end index by adding the partition size minus one to each start index. The result is a sequence of pairs, with each pair representing the start and end indices of a partition.</p> <h2 id="the-results">The Results</h2> <p>The aim of these changes was to decrease the memory usage of the Clojure implementation, and hopefully improve the scalability of the implementation. The memory usage was measured using Process Explorer for a 5x5 game using one thread. Recall that the C++ implementation of the algorithm used only 1.7 MB of memory, while the initial Clojure implementation used 3.3 GB of memory.</p> <h3 id="improved-implementation-in-clojure">Improved Implementation in Clojure#</h3> <p>The improved Clojure implementation does indeed use less memory, consuming 2.5 GB. However, the memory usage is still significantly higher than the C++ implementation. Did this change improve the scalability of the implementation?</p> <p><a href="https://docs.google.com/spreadsheet/pub?key=0Aviq84mNTIzZdFlfMjdqaWNCSHBEQ3NYcFFPNTQyc2c&amp;single=true&amp;gid=4&amp;output=html" rel="external nofollow noopener" target="_blank"><img src="/static/images/improving-scalability-in-clojure/nash-clojure-fix-memory-run-times.png" alt="Nash Clojure implementation (with memory fix) run times chart" title="Nash Clojure implementation (with memory fix) run times - follow the link to see the raw data."></a></p> <p>It looks like the scalability is not improved, so the high memory usage is likely still leading to false sharing.</p> <h3 id="improved-implementation-in-clojure-clr">Improved Implementation in Clojure CLR#</h3> <p>Still uncertain about whether the memory usage stemmed from my implementation, Clojure itself, or the JVM, I also tested this Clojure implementation using the <a href="https://github.com/clojure/clojure-clr" rel="external nofollow noopener" target="_blank">Clojure CLR</a> port, which is an implementation of Clojure on the .NET runtime. I made a few changes, only replacing calls to Java with calls to C# in my code and the Clojure libraries I used. The Clojure CLR implementation of this algorithm is available <a href="https://github.com/joshpeterson/nash-clojure/tree/CLR" rel="external nofollow noopener" target="_blank">here</a>.</p> <p>The memory usage pattern for Clojure CLR is rather different from the JVM implementation. Where the JVM implementation used a relatively constant amount of memory throughout the run, the CLR implementation started with a smaller memory footprint that continually increased. For the same problem size (5x5 games with one thread), the CLR implementation started off using 42 MB of memory, and increased to a maximum of 396 MB.</p> <p>Although the memory usage was much less for the CLR implementation, the wall clock run time was much longer. To measure the scalability of the CLR implementation, I had to use an even smaller game size, 4x4 games. The chart below shows the scalability of the CLR implementation.</p> <p><a href="https://docs.google.com/spreadsheet/pub?key=0Aviq84mNTIzZdFlfMjdqaWNCSHBEQ3NYcFFPNTQyc2c&amp;single=true&amp;gid=6&amp;output=html" rel="external nofollow noopener" target="_blank"><img src="/static/images/improving-scalability-in-clojure/nash-clojure-clr-run-times.png" alt="Nash Clojure CLR implementation run times chart" title="Nash Clojure CLR implementation run times - follow the link to see the raw data."></a></p> <p>This implementation shows slightly better scalability than the JVM implementation, but it is still not nearly linear scalability, which I would expect from an algorithm with no intrinsic data sharing.</p> <h3 id="cache-misses">Cache Misses#</h3> <p>Last time, I surmised that the increased memory usage of the Clojure implementation may have lead to more cache misses than the C++ implementation, which in turn caused the scalability to suffer. I again measured the L2 and L3 cache misses with Intel VTune for the new JVM and CLR implementations. The data obtained are shown below:</p> <center> <table class="gridtable"> <tr> <th></th> <th>C++</th> <th>Clojure</th> <th>Clojure (memory fix)</th> <th>Clojure (CLR)</th> </tr> <tr> <td>L2 cache miss percentage</td> <td>0.95%</td> <td>8.16%</td> <td>6.10%</td> <td>2.62%</td> </tr> <tr> <td>L3 cache miss percentage</td> <td>0.01%</td> <td>4.19%</td> <td>3.19%</td> <td>2.73%</td> </tr> </table> </center> <p>The improved Clojure algorithms do use less memory, and see fewer cache misses. The improved Clojure JVM implementation still uses a significant amount of memory, and as such, only has slightly fewer cache misses than the original JVM implementation.</p> <p>Do these cache miss measurements correspond to improved scalability?</p> <h3 id="scalability-comparison">Scalability Comparison#</h3> <p>To have a better view of the differences in scalability between these four implementations, I calculated the percent error between the expected linear scalability wall clock time and the actual wall clock time for each number of threads. The chart below shows the comparison.</p> <p><a href="https://docs.google.com/spreadsheet/pub?key=0Aviq84mNTIzZdFlfMjdqaWNCSHBEQ3NYcFFPNTQyc2c&amp;single=true&amp;gid=8&amp;output=html" rel="external nofollow noopener" target="_blank"><img src="/static/images/improving-scalability-in-clojure/scalability-comparison.png" alt="Comparison of scalability chart" title="Scalability comparison - follow the link to see the raw data."></a></p> <p>With the lack of actual data sharing, and the small memory footprint of the C++ implementation preventing false sharing, the imperative implementation maintains a consistent error of about 4% worse than linear scalability.</p> <p>It is more interesting, I think, to compare the Clojure JVM and CLR implementations. Although the CLR implementation is significantly slower (in wall clock time) than the JVM implementations, it does exhibit scalability closer to the ideal linear scalability. In the JVM, both the original Clojure implementation and the one with less memory exhibit nearly identical scalability.</p> <p>For this algorithm then, it seems that scalability is related to memory usage, and more specifically, to cache misses. The smaller the memory footprint, the smaller the time spent by the implementation waiting on cache misses, and the better the scalability.</p> <h2 id="conclusion">Conclusion</h2> <p>After this analysis, it seems the Clojure may not have been a good candidate to measure the scalability of this algorithm in a functional language. Clojure is a dynamic language, in the same family as Ruby or Python. It removes control of memory usage from the developer <em>by design</em>. Both of the Clojure JVM implementations used much less memory on my laptop (where less memory is available) than on the desktop machine I used for testing. For many applications, this design decision is acceptable and often beneficial. Still, I suspect a more experienced Clojure developer could further improve the memory usage of my implementation, and therefore improve the scalability as well.</p> <p>Scalability is difficult to achieve. An algorithm with no intrinsic data sharing can be implemented to scale in an imperative or functional language with little difference. Since the algorithm doesn’t require mutable state, the benefits of eliminating mutable state are not a significant advantage for the functional language.</p> <p>More common cases will likely involve algorithms with data sharing, where mutable state can lead to contention in an imperative language. In these cases, functional languages, and features like Clojure’s software transactional memory, will often be beneficial.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/more-fun-with-loop-unrolling-cpp/">More fun with loop unrolling - C++</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/learning-loop-unrolling/">Learning loop unrolling</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/constraints-are-liberating/">Constraints are liberating</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/span-making-c-arrays-fun-since-2020/">Span - making C arrays fun since 2020</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/game-theory-fun-in-the-nfl/">Game theory fun in the NFL</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Josh Peterson. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: March 16, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>